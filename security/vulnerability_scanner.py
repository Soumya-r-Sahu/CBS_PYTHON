"""
Security Vulnerability Scanner for Core Banking System

This module provides vulnerability scanning capabilities to detect 
common security issues in the system configuration and code.
"""

import os
import sys
import logging
import re
import json
import datetime
import subprocess
from typing import Dict, List, Tuple, Set, Optional
from pathlib import Path

# Configure logger
logger = logging.getLogger(__name__)


class VulnerabilityScanner:
    """Scanner for detecting security vulnerabilities in the system"""
    
    def __init__(self, base_dir: Optional[str] = None):
        """
        Initialize vulnerability scanner
        
        Args:
            base_dir (str, optional): Base directory to scan
        """
        # Set base directory
        if base_dir:
            self.base_dir = Path(base_dir)
        else:
            # Default to current working directory
            self.base_dir = Path.cwd()
        
        # Define vulnerability patterns
        self.vulnerability_patterns = {
            "hardcoded_credentials": [
                re.compile(r'password\s*=\s*["\'](?!.*\$\{)(?!.*os\.environ)(?!.*get\()([^"\']+)["\']', re.IGNORECASE),
                re.compile(r'passwd\s*=\s*["\'](?!.*\$\{)(?!.*os\.environ)(?!.*get\()([^"\']+)["\']', re.IGNORECASE),
                re.compile(r'api_key\s*=\s*["\'](?!.*\$\{)(?!.*os\.environ)(?!.*get\()([^"\']+)["\']', re.IGNORECASE),
                re.compile(r'secret\s*=\s*["\'](?!.*\$\{)(?!.*os\.environ)(?!.*get\()([^"\']+)["\']', re.IGNORECASE),
                re.compile(r'token\s*=\s*["\'](?!.*\$\{)(?!.*os\.environ)(?!.*get\()([^"\']+)["\']', re.IGNORECASE),
            ],
            "sql_injection": [
                re.compile(r'execute\s*\(\s*[\'"].*?\%s.*?\+', re.IGNORECASE),
                re.compile(r'execute\s*\(\s*[\'"].*?\{.*?\}\.format', re.IGNORECASE),
                re.compile(r'execute\s*\(\s*[\'"].*?\%.*?\%', re.IGNORECASE),
                re.compile(r'execute\s*\(\s*[\'"].*?\+.*?\+', re.IGNORECASE)
            ],
            "xss_vulnerabilities": [
                re.compile(r'render_template.*?\+\s*[a-zA-Z0-9_]+', re.IGNORECASE),
                re.compile(r'\.html\s*\(.*?\+', re.IGNORECASE),
                re.compile(r'innerHTML\s*=', re.IGNORECASE),
                re.compile(r'document\.write\s*\(', re.IGNORECASE)
            ],
            "insecure_functions": [
                re.compile(r'eval\s*\(', re.IGNORECASE),
                re.compile(r'exec\s*\(', re.IGNORECASE),
                re.compile(r'os\.system\s*\(', re.IGNORECASE),
                re.compile(r'subprocess\.call\s*\((?!.*check\s*=\s*True)', re.IGNORECASE),
                re.compile(r'subprocess\.Popen\s*\((?!.*check\s*=\s*True)', re.IGNORECASE),
                re.compile(r'pickle\.loads\s*\(', re.IGNORECASE),
                re.compile(r'yaml\.load\s*\((?!.*Loader\s*=\s*SafeLoader)', re.IGNORECASE),
                re.compile(r'\.md5\s*\(', re.IGNORECASE),
                re.compile(r'hashlib\.md5\s*\(', re.IGNORECASE)
            ],
            "insecure_permissions": [
                re.compile(r'os\.chmod\s*\(.*?777', re.IGNORECASE),
                re.compile(r'os\.chmod\s*\(.*?0o777', re.IGNORECASE),
                re.compile(r'os\.chmod\s*\(.*?0777', re.IGNORECASE)
            ],
            "debug_enabled": [
                re.compile(r'DEBUG\s*=\s*True', re.IGNORECASE),
                re.compile(r'app\.debug\s*=\s*True', re.IGNORECASE),
                re.compile(r'debug\s*=\s*True', re.IGNORECASE)
            ],
            "missing_input_validation": [
                re.compile(r'request\.form\s*\[', re.IGNORECASE),
                re.compile(r'request\.args\s*\[', re.IGNORECASE),
                re.compile(r'request\.json\s*\[', re.IGNORECASE)
            ],
            "insecure_deserialization": [
                re.compile(r'loads\s*\(', re.IGNORECASE),
                re.compile(r'from_json\s*\(', re.IGNORECASE),
                re.compile(r'marshal\.loads\s*\(', re.IGNORECASE),
                re.compile(r'jsonpickle\.decode\s*\(', re.IGNORECASE)
            ],
            "insecure_random": [
                re.compile(r'random\.random\s*\(', re.IGNORECASE),
                re.compile(r'random\.choice\s*\(', re.IGNORECASE),
                re.compile(r'random\.randint\s*\(', re.IGNORECASE),
                re.compile(r'random\.seed\s*\(', re.IGNORECASE)
            ]
        }
        
        # File extensions to scan
        self.file_extensions = {
            ".py", ".js", ".html", ".htm", ".xml", ".yaml", ".yml", ".json",
            ".cfg", ".conf", ".ini", ".config", ".env"
        }
        
        # Directories to exclude
        self.exclude_dirs = {
            "__pycache__", ".git", ".venv", "venv", "env", "node_modules",
            "dist", "build", ".pytest_cache", "htmlcov", ".coverage"
        }
    
    def scan_file(self, file_path: Path) -> Dict[str, List[Tuple[int, str]]]:
        """
        Scan a file for vulnerabilities
        
        Args:
            file_path (Path): Path to the file to scan
            
        Returns:
            Dict[str, List[Tuple[int, str]]]: Detected vulnerabilities 
                with line numbers and matched text
        """
        results = {}
        
        try:
            # Check if the file extension should be scanned
            if file_path.suffix.lower() not in self.file_extensions:
                return results
            
            # Read file content
            with open(file_path, "r", encoding="utf-8", errors="ignore") as f:
                lines = f.readlines()
            
            # Check each line for vulnerability patterns
            for line_num, line in enumerate(lines, 1):
                for vuln_type, patterns in self.vulnerability_patterns.items():
                    for pattern in patterns:
                        matches = pattern.findall(line)
                        if matches:
                            if vuln_type not in results:
                                results[vuln_type] = []
                            results[vuln_type].append((line_num, line.strip()))
        
        except Exception as e:
            logger.error(f"Error scanning file {file_path}: {str(e)}")
        
        return results
    
    def scan_directory(self, dir_path: Optional[Path] = None) -> Dict:
        """
        Scan a directory recursively for vulnerabilities
        
        Args:
            dir_path (Path, optional): Directory to scan, defaults to base_dir
            
        Returns:
            Dict: Scan results with detected vulnerabilities
        """
        if dir_path is None:
            dir_path = self.base_dir
        
        results = {
            "scan_time": datetime.datetime.now().isoformat(),
            "base_directory": str(dir_path),
            "vulnerabilities": {},
            "summary": {}
        }
        
        total_files = 0
        vulnerable_files = 0
        
        # Walk through directory tree
        for root, dirs, files in os.walk(dir_path):
            # Skip excluded directories
            dirs[:] = [d for d in dirs if d not in self.exclude_dirs]
            
            root_path = Path(root)
            
            # Scan each file
            for file in files:
                file_path = root_path / file
                total_files += 1
                
                file_results = self.scan_file(file_path)
                if file_results:
                    # Found vulnerabilities
                    vulnerable_files += 1
                    
                    # Calculate relative path to base directory
                    rel_path = file_path.relative_to(dir_path)
                    
                    # Add to results
                    results["vulnerabilities"][str(rel_path)] = file_results
                    
                    # Update summary counts
                    for vuln_type in file_results:
                        if vuln_type not in results["summary"]:
                            results["summary"][vuln_type] = 0
                        results["summary"][vuln_type] += len(file_results[vuln_type])
        
        # Add summary statistics
        results["stats"] = {
            "total_files": total_files,
            "vulnerable_files": vulnerable_files,
            "vulnerability_percentage": (
                round(vulnerable_files / total_files * 100, 2) if total_files > 0 else 0
            )
        }
        
        return results
    
    def scan_dependencies(self) -> Dict:
        """
        Scan Python dependencies for known vulnerabilities
        
        Returns:
            Dict: Results of dependency scan
        """
        results = {
            "scan_time": datetime.datetime.now().isoformat(),
            "vulnerabilities": []
        }
        
        try:
            # Check if safety is installed
            try:
                import safety
                safety_available = True
            except ImportError:
                safety_available = False
            
            if not safety_available:
                # Try to install safety
                logger.info("Safety not found, attempting to install...")
                subprocess.check_call([sys.executable, "-m", "pip", "install", "safety"])
                safety_available = True
            
            if safety_available:
                # Run safety check
                logger.info("Running safety check on dependencies...")
                result = subprocess.run(
                    [sys.executable, "-m", "safety", "check", "--json"],
                    capture_output=True,
                    text=True
                )
                
                if result.returncode == 0:
                    # No vulnerabilities found
                    results["vulnerabilities"] = []
                else:
                    # Parse JSON output
                    try:
                        output = json.loads(result.stdout)
                        results["vulnerabilities"] = output.get("vulnerabilities", [])
                    except json.JSONDecodeError:
                        # Fallback to text parsing if JSON fails
                        vulnerabilities = []
                        for line in result.stdout.splitlines():
                            if "==" in line and "vulnerability found" in line.lower():
                                parts = line.split("==")
                                if len(parts) >= 2:
                                    vulnerabilities.append({
                                        "package": parts[0].strip(),
                                        "installed": parts[1].split()[0],
                                        "description": line
                                    })
                        results["vulnerabilities"] = vulnerabilities
            
        except Exception as e:
            logger.error(f"Error scanning dependencies: {str(e)}")
            results["error"] = str(e)
        
        return results
    
    def run_full_scan(self) -> Dict:
        """
        Run a full security scan including code and dependencies
        
        Returns:
            Dict: Complete scan results
        """
        results = {
            "scan_time": datetime.datetime.now().isoformat(),
            "code_scan": self.scan_directory(),
            "dependency_scan": self.scan_dependencies()
        }
        
        # Calculate risk score (simple algorithm)
        risk_score = 0
        
        # Code vulnerabilities
        code_summary = results["code_scan"]["summary"]
        for vuln_type, count in code_summary.items():
            # Weight different vulnerability types
            if vuln_type in ["sql_injection", "hardcoded_credentials"]:
                risk_score += count * 10  # High severity
            elif vuln_type in ["xss_vulnerabilities", "insecure_functions"]:
                risk_score += count * 7   # Medium-high severity
            else:
                risk_score += count * 5   # Medium severity
        
        # Dependency vulnerabilities
        risk_score += len(results["dependency_scan"]["vulnerabilities"]) * 8
        
        # Normalize score to 0-100 range
        results["risk_assessment"] = {
            "raw_score": risk_score,
            "normalized_score": min(100, risk_score),
            "risk_level": self._get_risk_level(risk_score)
        }
        
        return results
    
    def _get_risk_level(self, score: int) -> str:
        """
        Convert a risk score to a risk level
        
        Args:
            score (int): Risk score
            
        Returns:
            str: Risk level (Low, Medium, High, Critical)
        """
        if score < 10:
            return "Low"
        elif score < 40:
            return "Medium"
        elif score < 70:
            return "High"
        else:
            return "Critical"
    
    def generate_report(self, results: Dict, output_file: Optional[str] = None) -> str:
        """
        Generate a security report from scan results
        
        Args:
            results (Dict): Scan results
            output_file (str, optional): File to write report to
            
        Returns:
            str: Report content
        """
        # Generate timestamp
        timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
        report = f"""
# Core Banking System Security Scan Report
Scan Date: {timestamp}

## Risk Assessment
Risk Level: {results["risk_assessment"]["risk_level"]} ({results["risk_assessment"]["normalized_score"]}/100)

## Summary

### Code Scan
- Total Files Scanned: {results["code_scan"]["stats"]["total_files"]}
- Files with Vulnerabilities: {results["code_scan"]["stats"]["vulnerable_files"]} ({results["code_scan"]["stats"]["vulnerability_percentage"]}%)

### Vulnerabilities by Type:
"""
        
        # Add vulnerability type summary
        for vuln_type, count in results["code_scan"]["summary"].items():
            report += f"- {vuln_type.replace('_', ' ').title()}: {count}\n"
        
        report += """
## Detailed Findings

### Code Vulnerabilities
"""
        
        # Add detailed code vulnerabilities
        for file_path, vulns in results["code_scan"]["vulnerabilities"].items():
            report += f"\n### {file_path}\n"
            
            for vuln_type, instances in vulns.items():
                report += f"\n#### {vuln_type.replace('_', ' ').title()}\n"
                
                for line_num, line_text in instances:
                    report += f"- Line {line_num}: `{line_text}`\n"
        
        report += "\n### Dependency Vulnerabilities\n"
        
        # Add dependency vulnerabilities
        if not results["dependency_scan"]["vulnerabilities"]:
            report += "No dependency vulnerabilities found.\n"
        else:
            for vuln in results["dependency_scan"]["vulnerabilities"]:
                if isinstance(vuln, dict):
                    package = vuln.get("package", "Unknown")
                    installed = vuln.get("installed", "Unknown")
                    description = vuln.get("description", "No details available")
                    report += f"- **{package}** (version {installed}): {description}\n"
                else:
                    report += f"- {vuln}\n"
        
        report += """
## Recommendations

1. **Fix Critical Vulnerabilities First**: Address high-risk issues like SQL injection and hardcoded credentials immediately.
2. **Update Dependencies**: Update any packages with known security vulnerabilities.
3. **Implement Input Validation**: Ensure all user inputs are properly validated and sanitized.
4. **Use Environment Variables**: Move sensitive configuration to environment variables.
5. **Regular Scanning**: Run security scans regularly as part of the development process.
"""
        
        # Write report to file if requested
        if output_file:
            try:
                with open(output_file, "w") as f:
                    f.write(report)
            except Exception as e:
                logger.error(f"Error writing report to {output_file}: {str(e)}")
        
        return report


# Create singleton instance
vulnerability_scanner = VulnerabilityScanner()

# Export main functions for easy access
scan_directory = vulnerability_scanner.scan_directory
scan_dependencies = vulnerability_scanner.scan_dependencies
run_full_scan = vulnerability_scanner.run_full_scan
generate_report = vulnerability_scanner.generate_report


if __name__ == "__main__":
    # Run a full scan if executed directly
    print("Running security vulnerability scan...")
    results = run_full_scan()
    
    # Generate and print report
    report = generate_report(results)
    print(report)
    
    # Save report to file
    report_file = "security_scan_report.md"
    with open(report_file, "w") as f:
        f.write(report)
    
    print(f"\nReport saved to {report_file}")
    
    # Print risk level
    risk_level = results["risk_assessment"]["risk_level"]
    print(f"\nOverall risk level: {risk_level}")
    
    # Exit with status code based on risk level
    if risk_level == "Critical":
        sys.exit(2)
    elif risk_level == "High":
        sys.exit(1)
    else:
        sys.exit(0)
